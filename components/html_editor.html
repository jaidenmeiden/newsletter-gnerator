<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 10px;
            font-family: Arial, sans-serif;
            background-color: #0e1117;
        }
        #editor-container {
            height: 200px;
            margin-bottom: 10px;
        }
        .ql-container {
            font-size: 14px;
            background-color: #0e1117;
            color: #ffffff;
        }
        .ql-editor {
            min-height: 150px;
            color: #ffffff;
        }
        .ql-editor.ql-blank::before {
            color: #888888;
        }
        /* Toolbar styling for better visibility */
        .ql-toolbar {
            background-color: #0e1117;
            border: 1px solid #444444;
            border-radius: 4px;
        }
        .ql-toolbar .ql-stroke {
            stroke: #ffffff;
        }
        .ql-toolbar .ql-fill {
            fill: #ffffff;
        }
        .ql-toolbar button:hover,
        .ql-toolbar button:focus,
        .ql-toolbar button.ql-active {
            background-color: #444444;
        }
        .ql-toolbar button:hover .ql-stroke,
        .ql-toolbar button:focus .ql-stroke,
        .ql-toolbar button.ql-active .ql-stroke {
            stroke: #ffffff;
        }
        .ql-toolbar button:hover .ql-fill,
        .ql-toolbar button:focus .ql-fill,
        .ql-toolbar button.ql-active .ql-fill {
            fill: #ffffff;
        }
        .ql-toolbar .ql-picker-label {
            color: #ffffff;
        }
        .ql-toolbar .ql-picker-options {
            background-color: #2d2d2d;
            border: 1px solid #444444;
        }
        .ql-toolbar .ql-picker-item {
            color: #ffffff;
        }
        .ql-toolbar .ql-picker-item:hover {
            background-color: #444444;
        }
        /* Editor border */
        .ql-container.ql-snow {
            border: 1px solid #444444;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div id="editor-container"></div>
    <script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>
    <script>
        (function() {
            // Get initial value from placeholder
            const initialValue = '{{INITIAL_VALUE}}';
            const decodedValue = initialValue !== '{{INITIAL_VALUE}}' 
                ? initialValue.replace(/&quot;/g, '"').replace(/&#39;/g, "'")
                : '';
            
            // Initialize Quill editor
            const quill = new Quill('#editor-container', {
                theme: 'snow',
                modules: {
                    toolbar: [
                        [{ 'header': [1, 2, 3, false] }],
                        ['bold', 'italic', 'underline', 'strike'],
                        [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                        [{ 'color': [] }, { 'background': [] }],
                        ['link'],
                        ['clean']
                    ]
                },
                placeholder: 'Enter text here...'
            });
            
            // Set initial content
            if (decodedValue) {
                quill.root.innerHTML = decodedValue;
            }
            
            // Get the textarea key and element ID from placeholders
            const textareaKey = '{{TEXTAREA_KEY}}';
            const elementId = '{{ELEMENT_ID}}';
            
            // Function to update textarea in parent window
            function updateTextArea(html) {
                if (window.parent && window.parent !== window) {
                    try {
                        const iframe = window.frameElement;
                        if (!iframe) return;
                        
                        const textareas = window.parent.document.querySelectorAll('textarea');
                        let targetTextarea = null;
                        
                        // Method 1: Find textarea by position - it should be directly below this iframe
                        // This is the most reliable method since Streamlit renders components in order
                        const iframeRect = iframe.getBoundingClientRect();
                        const candidates = Array.from(textareas).filter(ta => {
                            const taRect = ta.getBoundingClientRect();
                            // Textarea should be below the iframe
                            const isBelow = taRect.top >= iframeRect.bottom - 5; // 5px tolerance
                            // Textarea should be roughly aligned horizontally
                            const isAligned = Math.abs(taRect.left - iframeRect.left) < 50;
                            // Textarea should be close (within 200px below)
                            const isClose = (taRect.top - iframeRect.bottom) < 200;
                            return isBelow && isAligned && isClose;
                        });
                        
                        // If we found candidates, use the closest one
                        if (candidates.length > 0) {
                            // Sort by distance from iframe bottom
                            candidates.sort((a, b) => {
                                const aDist = a.getBoundingClientRect().top - iframeRect.bottom;
                                const bDist = b.getBoundingClientRect().top - iframeRect.bottom;
                                return aDist - bDist;
                            });
                            targetTextarea = candidates[0];
                        }
                        
                        // Method 2: Fallback - find by label text matching
                        if (!targetTextarea) {
                            textareas.forEach(ta => {
                                // Find all labels and check which one is associated with this textarea
                                const labels = window.parent.document.querySelectorAll('label');
                                labels.forEach(label => {
                                    const labelFor = label.getAttribute('for');
                                    const labelText = label.textContent || '';
                                    
                                    // Check if this label is for our textarea
                                    if (labelFor && ta.id === labelFor) {
                                        // Match based on key patterns
                                        if (textareaKey.includes('header_text') && labelText.includes('Header Text')) {
                                            targetTextarea = ta;
                                        } else if (textareaKey.includes('content_')) {
                                            // Extract layer number from key
                                            const keyMatch = textareaKey.match(/content_(\d+)/);
                                            if (keyMatch) {
                                                const layerNum = keyMatch[1];
                                                // Check if label mentions this layer number
                                                if (labelText.includes(`Layer ${layerNum}`) || 
                                                    labelText.includes(`Main Content - Layer ${layerNum}`)) {
                                                    targetTextarea = ta;
                                                }
                                            }
                                        }
                                    }
                                });
                            });
                        }
                        
                        if (targetTextarea) {
                            // Store the current value to compare later
                            const oldValue = targetTextarea.value;
                            
                            // Check if textarea is currently focused - if so, don't update to avoid losing focus
                            const isTextareaFocused = document.activeElement === targetTextarea || 
                                                      window.parent.document.activeElement === targetTextarea;
                            
                            // Only update if textarea is not focused (user is editing in editor, not textarea)
                            if (!isTextareaFocused) {
                                // Update the textarea value
                                targetTextarea.value = html;
                                
                                // Create and dispatch input event (most important for Streamlit)
                                const inputEvent = new Event('input', { 
                                    bubbles: true, 
                                    cancelable: true 
                                });
                                
                                // Set the value property directly (some frameworks need this)
                                Object.getOwnPropertyDescriptor(
                                    window.HTMLTextAreaElement.prototype, 
                                    "value"
                                ).set.call(targetTextarea, html);
                                
                                // Dispatch multiple events to ensure Streamlit catches it
                                targetTextarea.dispatchEvent(inputEvent);
                                
                                const changeEvent = new Event('change', { 
                                    bubbles: true, 
                                    cancelable: true 
                                });
                                targetTextarea.dispatchEvent(changeEvent);
                                
                                // Also try keyup event (but NOT focus/blur to avoid interrupting editor)
                                targetTextarea.dispatchEvent(new KeyboardEvent('keyup', { 
                                    bubbles: true, 
                                    cancelable: true 
                                }));
                                
                                // DO NOT trigger focus/blur - this causes the editor to lose focus
                                // The events above should be enough for Streamlit to detect the change
                                
                                // Also try to trigger Streamlit's update mechanism directly
                                if (targetTextarea.oninput) {
                                    targetTextarea.oninput(inputEvent);
                                }
                                if (targetTextarea.onchange) {
                                    targetTextarea.onchange(changeEvent);
                                }
                                
                                // Try to access Streamlit's internal update mechanism
                                try {
                                    const streamlitDoc = window.parent.document;
                                    if (streamlitDoc) {
                                        const customEvent = new CustomEvent('streamlit:update', {
                                            detail: { value: html, key: textareaKey },
                                            bubbles: true
                                        });
                                        targetTextarea.dispatchEvent(customEvent);
                                    }
                                } catch (e) {
                                    // Ignore errors in accessing Streamlit internals
                                }
                            }
                        } else {
                            console.log('Could not find target textarea for key:', textareaKey, 'elementId:', elementId);
                        }
                    } catch (e) {
                        console.log('Could not update textarea:', e);
                    }
                }
            }
            
            // Function to send content to Streamlit
            function sendToStreamlit() {
                const html = quill.root.innerHTML;
                updateTextArea(html);
            }
            
            // Debounce function to avoid too many updates
            let debounceTimer;
            let lastSentValue = '';
            
            function debouncedSend() {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => {
                    const html = quill.root.innerHTML;
                    // Only send if value actually changed
                    if (html !== lastSentValue) {
                        lastSentValue = html;
                        sendToStreamlit();
                    }
                }, 500);
            }
            
            // Listen for content changes
            quill.on('text-change', debouncedSend);
            
            // Also listen for selection changes to ensure we capture all edits
            quill.on('selection-change', function(range) {
                if (range) {
                    // User is editing, make sure we capture the change
                    debouncedSend();
                }
            });
            
            // Listen for messages from parent to update editor content
            window.addEventListener('message', function(event) {
                if (event.data && event.data.type === 'update-editor-content') {
                    quill.root.innerHTML = event.data.html || '';
                }
            });
            
            // Store reference for external access
            window.quillEditor = quill;
            window.updateEditorContent = function(html) {
                quill.root.innerHTML = html || '';
            };
        })();
    </script>
</body>
</html>

